1. Define a common event fields and create a corrosponding definitions for the fluentd config file.

    Every SIEM vendors follow different field names and terms, but there is no common format. Hence instead of creating our own fields (and not adding another format to the list of available ones.), let's adopt some other format. 

    I'm going to take wireshark fields. (BTW it's also indirectly help us to remaind these filters and fields.) 

Here are the some of the fields and major parts. 

old_field | new_field
----------|-----------
method|http.request.method|
code |http.response.code
uri |http.request.uri.path
NA |http.request.uri -> combination of host + uri
agent| http.user_agent
host |http.host
referer| http.referer
size |http.data.size # this one not available, hence added it ourself.
user |http.user
uid | zeek.id
id.orig_h|ip.src
id.orig_p| port.src // if the "proto" is tcp we can add tcp.srcport, similarly for udp we can add udp.srcport
id.resp_h| ip.dst
id.resp_p| port.dst
proto| NA
duration|session.duration
orig_bytes|na
resp_bytes| na
conn_state|na
history|na
ip_proto|na



2. Find a way to store the raw logs in a separate file/index/any cloud storage for the compliance purpose. These raw log's does not need to parsed events. 


Simple fluentd configuration for reading apache2 logs and send it to stdout, without adding/removing anything to the event.

```
  GNU nano 7.2                                               /etc/fluent/fluentd_store_raw_log.conf                                                         <source>
        @type tail
        path /var/log/apache2/access.log
        pos_file /var/log/fluent/apache2.access_log.pos
        <parse>
                @type apache2
        </parse>
        tag application.raw.apache2
</source>


<match application.raw.apache2>
  @type stdout
</match>
```

`2025-08-31 10:56:48.000000000 +0000 application.raw.apache2: {"host":"172.25.99.181","user":null,"method":"HEAD","path":"/","code":200,"size":255,"referer":null,"agent":"curl/8.5.0"}`

Now let's try to modify the event and also try to preserve the original event also. 

    I tried differnt methods. For now it's seems we can't send the raw logs and parsed logs to the differnt opensearch index. 

    Let's think of the below posibilites
        1) Create a new plugin to send the logs to diff index
            Assumming like the plugin will read the data, 
            and our custom plugin should emmit new events with modified tag, while also keeping the old event.
                So here, we do the processing part and it's not easy for the beginer to create plugins. but We'll try.  


        2) Send the source data to another differnt local forwarder using match, and then in that forwarder on receving set the tag to differnt name, and create a  another matcher to send this raw log to openserach. 

        read Log;tag: raw_log2; -> 
            matcher 1 -> forward logs to local port or save it local file -> on receving/reading the saved file again, set the tag: raw_log2 -> and send it to opensearch.

            matcher 2 -> parse the raw_log1 -> send it to Opensearch

            In the above case, we need to read/save and read it again, So basically one read and one write operations required. it's not efficient. 


